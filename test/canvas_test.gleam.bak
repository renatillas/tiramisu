import gleam/option
import paint as p
import tiramisu/scene
import tiramisu/transform
import vec/vec3

type TestId {
  Canvas1
  Canvas2
}

/// Test that adding a canvas generates an AddNode patch
pub fn diff_add_canvas_test() {
  let picture = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))

  let prev = option.None
  let next = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]

  let patches = scene.diff(prev, next)

  case patches {
    [scene.AddNode(id: Canvas1, node: _, parent_id: option.None)] -> Nil
    _ -> panic as "Expected AddNode patch for canvas"
  }
}

/// Test that removing a canvas generates a RemoveNode patch
pub fn diff_remove_canvas_test() {
  let picture = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))

  let prev = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]
  let next = []

  let patches = scene.diff(prev, next)

  case patches {
    [scene.RemoveNode(id: Canvas1)] -> Nil
    _ -> panic as "Expected RemoveNode patch for canvas"
  }
}

/// Test that identical canvas nodes generate no patches (encoding optimization working)
pub fn diff_canvas_no_change_test() {
  let picture = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))

  let prev = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]
  let next = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]

  let patches = scene.diff(prev, next)

  case patches {
    [] -> Nil
    _ ->
      panic as "Expected no patches for identical canvas nodes (encoding optimization should prevent re-rendering)"
  }
}

/// Test that changing picture content generates UpdateCanvas patch
pub fn diff_canvas_picture_change_test() {
  let picture1 = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))
  let picture2 = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(0, 255, 0))

  let prev = [
    scene.canvas(
      id: Canvas1,
      picture: picture1,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]
  let next = [
    scene.canvas(
      id: Canvas1,
      picture: picture2,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]

  let patches = scene.diff(prev, next)

  case patches {
    [scene.UpdateCanvas(id: Canvas1, ..)] -> Nil
    _ -> panic as "Expected UpdateCanvas patch when picture changes"
  }
}

/// Test that changing texture dimensions generates UpdateCanvas patch
pub fn diff_canvas_dimensions_change_test() {
  let picture = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))

  let prev = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]
  let next = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 512,
      texture_height: 128,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]

  let patches = scene.diff(prev, next)

  case patches {
    [scene.UpdateCanvas(id: Canvas1, ..)] -> Nil
    _ -> panic as "Expected UpdateCanvas patch when texture dimensions change"
  }
}

/// Test that changing canvas size generates UpdateCanvas patch
pub fn diff_canvas_size_change_test() {
  let picture = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))

  let prev = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]
  let next = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 4.0,
      height: 1.0,
      transform: transform.identity,
      children: [],
    ),
  ]

  let patches = scene.diff(prev, next)

  case patches {
    [scene.UpdateCanvas(id: Canvas1, ..)] -> Nil
    _ -> panic as "Expected UpdateCanvas patch when canvas size changes"
  }
}

/// Test that changing transform generates UpdateCanvas patch
pub fn diff_canvas_transform_change_test() {
  let picture = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))

  let prev = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]
  let next = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.at(vec3.Vec3(5.0, 10.0, 0.0)),
      children: [],
    ),
  ]

  let patches = scene.diff(prev, next)

  case patches {
    [scene.UpdateCanvas(id: Canvas1, ..)] -> Nil
    _ -> panic as "Expected UpdateCanvas patch when transform changes"
  }
}

/// Test encoding optimization: Creating the same picture twice should generate identical encoded strings
pub fn canvas_encoding_consistency_test() {
  let picture1 = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))
  let picture2 = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))

  let canvas1 =
    scene.canvas(
      id: Canvas1,
      picture: picture1,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    )

  let canvas2 =
    scene.canvas(
      id: Canvas1,
      picture: picture2,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    )

  // If encoding is consistent, diff should produce no patches
  let patches = scene.diff([canvas1], [canvas2])

  case patches {
    [] -> Nil
    _ ->
      panic as "Expected no patches - identical pictures should encode to identical strings"
  }
}

/// Test that multiple canvas updates work correctly
pub fn diff_multiple_canvas_test() {
  let picture = p.rectangle(256.0, 64.0) |> p.fill(p.colour_rgb(255, 0, 0))

  let prev = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
  ]
  let next = [
    scene.canvas(
      id: Canvas1,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.identity,
      children: [],
    ),
    scene.canvas(
      id: Canvas2,
      picture: picture,
      texture_width: 256,
      texture_height: 64,
      width: 2.0,
      height: 0.5,
      transform: transform.at(vec3.Vec3(5.0, 0.0, 0.0)),
      children: [],
    ),
  ]

  let patches = scene.diff(prev, next)

  // Should only have AddNode for Canvas2, no update for Canvas1
  case patches {
    [scene.AddNode(id: Canvas2, ..)] -> Nil
    _ -> panic as "Expected only AddNode patch for new canvas"
  }
}
